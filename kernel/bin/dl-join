#!/bin/bash

set -e

. /etc/docklet/docklet.conf

function log_msg {
	TYPE=$1 && shift && COLOR=35
	[[ "${TYPE}" == "INFO" ]] && COLOR=34
	[[ "${TYPE}" == "WARN" ]] && COLOR=33
	[[ "${TYPE}" == "ERROR" ]] && COLOR=31
	echo -e "\033[${COLOR}m[${TYPE}] $@\033[0m" > /dev/stderr
	[[ "${TYPE}" == "ERROR" ]] && exit 1
	return 0
}

function blink {
	nmap -sP "$@" | grep report | awk '{print $NF}' | awk -F\( '{print $NF}' | awk -F\) '{print $1}'
}

function get_address {
	UNIONS=$(echo -e "`blink ${MACHINE_CIDR}`\n`ip addr | grep inet\  | awk '{print $2}' | awk -F\/ '{print $1}'`" | sort)

	for MY_IP in ${UNIONS}; do
		[[ "${PREV_IP}" == "${MY_IP}" ]] && break
		PREV_IP=${MY_IP}
	done
	echo ${MY_IP}
	unset UNIONS PREV_IP MY_IP
}

if [[ "$@" == "network" ]]; then
	get_address
	exit 0
fi

log_msg "INFO" "Docklet Cluster for Ubuntu distribution x86_64."

[[ "`uname -a | grep x86_64`" == "" ]] && log_msg "ERROR" "Only x86_64-arch is supported."

[[ "`whoami`" != "root" ]] && log_msg "ERROR" "Root previledge required!"

if [[ "`cat /proc/cmdline | grep cgroup`" == "" ]]; then
	log_msg "ERROR" "Memory limit not enabled!"
fi

ip link delete lxcbr0 >/dev/null 2>&1 || true

if [[ "${MACHINE_CIDR}" == "127.0.0.1/32" ]]; then
	log_msg "WARN" "Setting up for localhost."
	
	if [[ ! -e "/root/.ssh/id_rsa" ]] && [[ ! -e "/root/.ssh/authorized_keys" ]]; then
		mv /root/.ssh/id_rsa /root/.ssh/id_rsa.bak 2>/dev/null || true
		mv /root/.ssh/id_rsa.pub /root/.ssh/id_rsa.pub.bak 2>/dev/null || true
		mv /root/.ssh/authorized_keys /root/.ssh/authorized_keys.bak 2>/dev/null || true
		
		echo -e '\n' | ssh-keygen -t rsa -P '' >/dev/null 2>&1
		mv /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys
	fi
	
	ssh -oStrictHostKeyChecking=no root@0.0.0.0 true
fi

log_msg "INFO" "Finish setting up."

MY_IP=`get_address`

log_msg "INFO" "IP of this host is ${MY_IP}."

#lxc-stop -n core-service -k >/dev/null 2>&1 || true
#killall lxc-start >/dev/null 2>&1 || true
#killall etcd >/dev/null 2>&1 || true
killall dl-httprest >/dev/null 2>&1 || true

log_msg "INFO" "Make sure all resources are released .."

mkdir -p ${NFS_PREFIX}/global

if ! mountpoint ${NFS_PREFIX}/global -q; then
	log_msg "INFO" "Remounting NFS ${NFS_PREFIX}/global .."
	`${NFS_MOUNT_CMD}`
fi

log_msg "INFO" "Setting up for global .."

mkdir -p ${NFS_PREFIX}/global/images ${NFS_PREFIX}/global/users


log_msg "INFO" "Setting up for local .."

LOOP="${NFS_PREFIX}/local/dl-localdevmapper.lo"

if [[ ! -e "${LOOP}" ]]; then
	mkdir -p `dirname "${LOOP}"`
	dd if=/dev/zero of=${LOOP} bs=1M seek=102400 count=0 # 100G
fi

losetup /dev/loop0 ${LOOP} >/dev/null 2>&1 || true
vgcreate dl-devmapper /dev/loop0 >/dev/null 2>&1 || true

# umount -l /var/lib/lxc/*/rootfs ${NFS_PREFIX}/local/volumes/* >/dev/null 2>&1 || true

mkdir -p ${NFS_PREFIX}/local/volumes

if [[ ! -e "${NFS_PREFIX}/local/filesystem/nfs" ]]; then
	[[ ! -e "/home/docklet/filesystem.tgz" ]] && log_msg "ERROR" "Rootfs Image Not Found!"
	
	mkdir -p ${NFS_PREFIX}/local/filesystem/nfs
	tar xzvf /home/docklet/filesystem.tgz -C ${NFS_PREFIX}/local/filesystem >/dev/null
fi


cd ${NFS_PREFIX}/local/filesystem

function setup {
	rm -rf dev/console dev/null dev/zero dev/tty dev/random dev/urandom
	mknod -m 622 dev/console c 5 1
	mknod -m 666 dev/null c 1 3
	mknod -m 666 dev/zero c 1 5
	rm -rf dev/ptmx ; mknod -m 666 dev/ptmx c 5 2
	mknod -m 666 dev/tty c 5 0
	mknod -m 444 dev/random c 1 8
	mknod -m 444 dev/urandom c 1 9

	rm -rf dev/fd dev/stdin dev/stdout dev/stderr
	ln -s /proc/self/fd/0 dev/stdin
	ln -s /proc/self/fd/1 dev/stdout
	ln -s /proc/self/fd/2 dev/stderr
	ln -s /proc/self/fd dev/fd
}

setup

#tar czvf ${NFS_PREFIX}/global/images/pub_root_base.tgz ./ >/dev/null

echo "LANG=en_US.UTF-8" > etc/default/locale


#HOSTS="`blink ${MACHINE_CIDR}`"
#PEERS=""
#for MIP in $HOSTS; do
#	if nc -q 0 $MIP 7001 </dev/null >/dev/null 2>&1; then
#		PEERS="--peers $MIP:7001"
#		log_msg "INFO" "Machine discovery: ${MIP}"
#		break
#	fi
#done

cd ${NFS_PREFIX}/global

mkdir -p database/{instances,machines}
touch database/machines/${MY_IP}

#[[ "${PEERS}" == "" ]] && rm -rf ./etcd

#log_msg "WARN" "etcd -peer-addr ${MY_IP}:7001 -addr ${MY_IP}:4001 -data-dir etcd/${MY_IP} -name ${MY_IP} ${PEERS}"
#nohup etcd -peer-addr ${MY_IP}:7001 -addr ${MY_IP}:4001 -data-dir etcd/${MY_IP} -name ${MY_IP} ${PEERS} >/dev/null 2>&1 &

#log_msg "INFO" "Waiting etcd to get ready .." && sleep 2

#domainname $(echo ${NIS_SERVER} | awk '{print $2}') >/dev/null 2>&1

if ! ip addr show ovs-bridge | grep 10.10.0.1 >/dev/null; then
	iptables -F
	iptables -t nat -F
	iptables -t nat -A POSTROUTING -s 10.10.0.0/16 -j MASQUERADE

	ip link set ovs-link down 2>/dev/null || true
	ip link set ovs-bridge down 2>/dev/null || true

	ovs-vsctl del-br ovs-link 2>/dev/null || true
	ovs-vsctl add-br ovs-link
	brctl delbr ovs-bridge 2>/dev/null || true
	brctl addbr ovs-bridge

	ip link set dev ovs-bridge up
	ip link set ovs-link up

	sleep 3s
	
	brctl addif ovs-bridge ovs-link
	ip addr add 10.10.0.1/16 dev ovs-bridge broadcast 10.10.255.255
fi

#LIVE_HOSTS="$(KEY='/_etcd/machines' etcd ls | awk -F\/ '{print $NF}')" >/dev/null 2>&1

#for HOST in ${LIVE_HOSTS}; do
#        [[ "${HOST}" == "${MY_IP}" ]] && continue
#
#        ovs-vsctl add-port ovs-link gre-${HOST} -- set interface gre-${HOST} type=gre options:remote_ip=${HOST}
#        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${HOST} ovs-vsctl add-port ovs-link gre-${MY_IP} -- set interface gre-${MY_IP} type=gre options:remote_ip=${MY_IP} || true
#	break
#done

log_msg "INFO" "Finish all initialization .."

RECOVERY=`lxc-ls` || true

if [[ "${RECOVERY}" != "" ]]; then
	for UUID in ${RECOVERY}; do
		if [[ "`lxc-info -n ${UUID} -p 2>/dev/null`" == "" ]]; then
			log_msg "INFO" "Recoverying lxc - ${UUID} .."
			docklet-weave start ${UUID}
		fi
	done
fi

nohup dl-httprest >/dev/null 2>&1 &

