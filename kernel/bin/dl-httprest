#!/usr/bin/python3

import traceback, re, random
import os, subprocess, json, sys
import posixpath, urllib, cgi, shutil, mimetypes

import subprocess as commands
from http.server import BaseHTTPRequestHandler, HTTPServer

class DockletHTTPRequestHandler(BaseHTTPRequestHandler):

	def sys_append_log(self, text):
		f = open('/var/log/dl-httprest.log', 'a')
		f.write(text)
		f.write('\n')
		f.close()

	def execute(self, command, node = '0.0.0.0'):
		self.sys_append_log("[RPC] ssh %s %s 2>/dev/null" % (node, command))
		(status, output) = commands.getstatusoutput("ssh -o StrictHostKeyChecking=no %s '. /etc/docklet/docklet.conf; %s' 2>/dev/null" % (node, command))
		return output if status==0 else None

	def authenticate_with_headers(self, provider=None):
		[username, password] = provider if provider!=None else self.headers['Auth'].split('/', 1)
		if re.match('^[a-z0-9A-Z\-\_\@]{1,20}$',username)==None:
			raise Exception('illegal username!')
		if username=='root':
			loggedIn = False
		else:
			rsa_buff = commands.getoutput("cat /home/docklet/global/users/%s/ssh_keys/id_rsa 2>/dev/null" % username).strip().encode()
			loggedIn = (password == rsa_buff or password.encode() == rsa_buff)
			if not loggedIn:
				try:
					from pam import pam
					loggedIn = pam().authenticate(username, password)
				except:
					loggedIn = 'docklet' == username and 'docklet' == password
		if not loggedIn:
			raise Exception("authentication failed")
		
		return username

	def do_GET(self):
		try:
			username = self.authenticate_with_headers()
			self.sys_append_log("[REQ] GET %s" % self.path)
			if self.path == '/user/login':
				[openssh, init_pass] = self.execute("USER_NAME=%s stone" % username).split("========")
				openssh = openssh.strip()
				init_pass = init_pass.strip()
				obj = {'success':True, 'data': {'openssh': openssh, 'init_pass': init_pass } }
			else:
				raise Exception('unsupported request!')
		except Exception as e:
			self.sys_append_log(traceback.format_exc())
			obj = {'success':False, 'message': str(e)}
		
		self.send_response(200)
		self.send_header("Content-type", "application/json")
		self.end_headers()
		self.wfile.write(json.dumps(obj).encode())
		self.wfile.write('\n'.encode())
		#self.wfile.close()
		return
	
	def etcd_get_machines(self):
		return os.listdir('/home/docklet/global/database/machines/')

	def etcd_get_random_machine(self):
		cl = self.etcd_get_machines()
		return cl[random.randint(0, len(cl)-1)]

	def etcd_list_clusters(self, user):
		try:
			obj = os.listdir('/home/docklet/global/database/instances/')
			clusters = []
			for item in obj:
				try:
					datas = self.etcd_list_single_cluster(user, item)
					clusters.append(datas)
				except Exception as e:
					pass
			return clusters
		except Exception as e:
			self.sys_append_log(e)
			return {}

	def etcd_list_single_cluster(self, user, cl_id):
		datas = commands.getoutput('cat /home/docklet/global/database/instances/%s' % cl_id)
		[owner,image,cluster] = datas.split('|')
		if owner==user or user=='root':
			nodes = []
			for node in cluster.split():
				[work_on, uuid, nat_id, host_name] = node.split(':')
				nodes.append({'work_on':work_on, 'uuid':uuid, 'nat_id':nat_id, 'host_name':host_name})
			return {'id': cl_id, 'owner': owner, 'image': image, 'portal': '', 'nodes': nodes}
		raise Exception("cluster not found!")

	def on_post_request(self, context, user, form):
		if context.startswith('/clusters/'):
			context = context[10:].strip()
			if context == "":
				cls = self.etcd_list_clusters(user)
				return {'clusters': cls}
			
			parts = context.split('/')
			if parts[0]=="create":
				cls = self.etcd_list_clusters(user)
				if len(cls)>0:
					raise Exception("your cluster is already booted")
				#if re.match('^[a-z0-9]{1,10}_[a-z0-9\-]{1,20}$', image)==None:
				#	raise Exception("illegal image format, should like: owner_abc123-def")
				WORK_ON = self.etcd_get_random_machine()
				NAT_ID = self.execute('THIS_HOST=%s USER_NAME=%s pocket create' % (WORK_ON, user), WORK_ON)
				if NAT_ID == None:
					raise Exception("create operation failed")
				return {'id': NAT_ID, 'workon': WORK_ON, 'portal': str(10000+int(NAT_ID))}
			elif parts[0] == "remove":
				cls = self.etcd_list_clusters(user)
				obj = cls[0]['nodes']
				if len(obj)!=1:
					raise Exception("illegal number of cluster nodes")
				WORK_ON = obj[0]['work_on']
				clusterInt = int(cls[0]['id'])
				if self.execute('USER_NAME=%s NAT_ID=%s pocket remove' % (user, clusterInt), WORK_ON)==None:
					raise Exception("exit operation failed")
				return {'master': WORK_ON, 'natid': clusterInt}

			clusterInt = int(parts[0])
			op = parts[1]
			if op == "":
				return self.etcd_list_single_cluster(user, clusterInt)
			elif op == "scaleout":
				mac = self.etcd_get_random_machine()
				result = self.execute('USER_NAME=%s NAT_ID=%s THIS_HOST=%s pocket scaleout' % (user, clusterInt, mac), mac)
				if result == None:
					raise Exception("nodes number exceed the upbound limit")
				[ipaddr, workon, uuid, host] = result.split()
				return {'ip':ipaddr, 'uuid':uuid, 'host_name':host, 'work_on':workon}
			elif op == "scalein":
				obj = self.etcd_list_single_cluster(user, clusterInt)['nodes']
				if len(obj)<=1:
					raise Exception("no more slaves to release")
				s = obj[-2]
				[mac, uuid, ipaddr, hostname] = [s['work_on'], s['uuid'], s['nat_id'], s['host_name']]
				result = self.execute('USER_NAME=%s NAT_ID=%s THIS_HOST=%s pocket scalein' % (user, clusterInt, mac), mac)
				if result==None:
					raise Exception("nodes number exceed the lowerbound limit")
				return {'ip':ipaddr, 'uuid':uuid, 'host_name':hostname, 'work_on':mac}
			elif op == "restart":
				obj = self.etcd_list_single_cluster(user, clusterInt)['nodes']
				status = []
				for s in obj:
					[mac, uuid, ipaddr, hostname] = [s['work_on'], s['uuid'], s['nat_id'], s['host_name']]
					status.append({"uuid": uuid, "status": self.execute('docklet-weave start %s' % uuid, mac)!=None})
				return {"status": status}
			elif op == "remove":
				obj = self.etcd_list_single_cluster(user, clusterInt)['nodes']
				if len(obj)!=1:
					raise Exception("illegal number of cluster nodes")
				WORK_ON = obj[0]['work_on']
				if self.execute('USER_NAME=%s NAT_ID=%s pocket remove' % (user, obj[0]['uuid'].split('-')[1]), WORK_ON)==None:
					raise Exception("exit operation failed")
				return {'master': WORK_ON, 'natid': clusterInt}
			else:
				raise Exception("no node information found")
		
		raise Exception('unsupported request!')
	
	def do_POST(self):
		try:
			self.sys_append_log("[REQ] POST %s" % self.path)
			
			length = int(self.headers['content-length'])
			if length>10240000:
				raise Exception("data too large, handler cancelled")
			
			form = cgi.FieldStorage(fp=self.rfile, headers=self.headers,environ={'REQUEST_METHOD':'POST','CONTENT_TYPE': "text/html"})
			
			username = self.authenticate_with_headers([form['user'].value, form['key'].file.read().strip()])
			context = self.path.split('?')[0]
			if not context.endswith("/"):
				context = context + "/"
			obj = {'success':True, 'data': self.on_post_request(context, username, form)}
		except Exception as e:
			self.sys_append_log(traceback.format_exc())
			obj = {'success':False, 'message': str(e)}
		
		self.send_response(200)
		self.send_header("Content-type", "application/json")
		self.end_headers()
		self.wfile.write(json.dumps(obj).encode())
		self.wfile.write('\n'.encode())
		#self.wfile.close()
		return

if __name__ == '__main__':
	server = HTTPServer(('0.0.0.0', 8000), DockletHTTPRequestHandler)
	server.serve_forever()
